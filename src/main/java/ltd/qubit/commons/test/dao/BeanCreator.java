////////////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2022 - 2023.
//    Haixing Hu, Qubit Co. Ltd.
//
//    All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////
package ltd.qubit.commons.test.dao;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.annotation.Nullable;

import ltd.qubit.commons.random.Parameters;
import ltd.qubit.commons.random.RandomBeanGenerator;
import ltd.qubit.commons.reflect.BeanInfo;
import ltd.qubit.commons.reflect.Property;
import ltd.qubit.commons.util.Result;
import ltd.qubit.commons.util.range.CloseRange;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static ltd.qubit.commons.lang.ObjectUtils.defaultIfNull;
import static ltd.qubit.commons.lang.StringUtils.isEmpty;

/**
 * 用于创建随机Bean的类。
 *
 * @author 胡海星
 */
public class BeanCreator {

  public static final CloseRange<Integer> DEFAULT_SIZE_RANGE = new CloseRange<>(0, 5);

  private final Logger logger = LoggerFactory.getLogger(this.getClass());
  private final DaoTestGeneratorRegistry generatorRegistry;
  private final RandomBeanGenerator random;

  public BeanCreator(final DaoTestGeneratorRegistry generatorRegistry) {
    this.generatorRegistry = generatorRegistry;
    this.random = generatorRegistry.getRandom();
  }

  public Object prepareProperty(final Object model, final Property property)
      throws Throwable {
    logger.debug("Prepare the property {} of the model: {}", property.getName(),
        model);
    final Class<?> propType = property.getType();
    final BeanInfo propBeanInfo = BeanInfo.of(propType);
    final Object propValue = prepare(propBeanInfo);
    property.setValue(model, propValue);
    return propValue;
  }

  /**
   * 生成一个准备好的随机的Bean。
   *
   * <p>若该Bean有任何引用属性(即被{@code @Reference}标注的属性)，则此函数会生成其引
   * 用属性所引用的实体并根据需要将其预先加入数据库。</p>
   *
   * @param modelInfo
   *     待生成的随机Bean的信息。
   * @param nonNullProperties
   *     待生成的随机bean，这些property不应该为{@code null}.
   * @return
   *     准备好的随机的Bean。<b>注意：</b>如果该Bean的ID属性（该属性被标记注解{@code Identifier}）
   *     被标记为{@code autoGenerated=true}，则生成的模型的ID属性会被设置为{@code null}.
   * @throws Throwable
   *     如果出现任何错误。
   */
  public Object prepare(final BeanInfo modelInfo, final Property ... nonNullProperties)
      throws Throwable {
    logger.debug("Prepare the model: {}, nonNullProperties = {}",
        modelInfo.getName(), nonNullProperties);
    final Object result;
    if (nonNullProperties.length == 0) {
      result = prepareImpl(modelInfo, null, new EntityInfoStack(), new EntityRegistry());
    } else {
      // 记住旧的 random.parameters.nonNullFields
      final Parameters parameters = random.getParameters();
      final Set<Field> oldNonNullFields = new HashSet<>(parameters.getNonNullFields());
      // 设置新的 random.parameters.nonNullFields
      parameters.clearNonNullFields();
      for (final Property prop : nonNullProperties) {
        if (prop.isNullable() && prop.getField() != null) {
          parameters.addNonNullField(prop.getField());
          logger.debug("Set the field '{}' of the model '{}' to non-null.",
              prop.getName(), modelInfo.getName());
        }
      }
      // 准备实体对象
      result = prepareImpl(modelInfo, null, new EntityInfoStack(), new EntityRegistry());
      // 恢复旧的 random.parameters.nonNullFields
      parameters.setNonNullFields(oldNonNullFields);
    }
    logger.debug("The model {} was prepared: {}", modelInfo.getName(), result);
    return result;
  }

  /**
   * 生成一个准备好的随机的Bean。
   *
   * <p>若该Bean有任何引用属性(即被{@code @Reference}标注的属性)，则此函数会生成其引
   * 用属性所引用的实体并根据需要将其预先加入数据库。</p>
   *
   * @param modelInfo
   *     待生成的随机Bean的信息。
   * @return
   *     准备好的随机的Bean。<b>注意：</b>如果该Bean的ID属性（该属性被标记注解{@code Identifier}）
   *     被标记为{@code autoGenerated=true}，则生成的模型的ID属性会被设置为{@code null}.
   * @throws Throwable
   *     如果出现任何错误。
   */
  public Object prepare(final BeanInfo modelInfo) throws Throwable {
    logger.debug("Prepare the model: {}", modelInfo.getName());
    final Object result = prepareImpl(modelInfo, null, new EntityInfoStack(),
        new EntityRegistry());
    logger.debug("The model {} was prepared: {}", modelInfo.getName(), result);
    return result;
  }

  /**
   * 生成一个准备好的随机的Bean。
   *
   * <p>若该Bean有任何引用属性(即被{@code @Reference}标注的属性)，则此函数会生成其引
   * 用属性所引用的实体并根据需要将其预先加入数据库。</p>
   *
   * @param type
   *     待生成的随机Bean的类型。
   * @param nonNullProperties
   *     待生成的随机bean，这些property不应该为{@code null}.
   * @return
   *     准备好的随机的Bean。<b>注意：</b>如果该Bean的ID属性（该属性被标记注解{@code Identifier}）
   *     被标记为{@code autoGenerated=true}，则生成的模型的ID属性会被设置为{@code null}.
   * @throws Throwable
   *     如果出现任何错误。
   */
  @SuppressWarnings("unchecked")
  public <T> T prepare(final Class<T> type, final Property ... nonNullProperties)
      throws Throwable {
    return (T) prepare(BeanInfo.of(type), nonNullProperties);
  }

  /**
   * 生成一个准备好的随机的Bean。
   *
   * <p>若该Bean有任何引用属性(即被{@code @Reference}标注的属性)，则此函数会生成其引
   * 用属性所引用的实体并根据需要将其预先加入数据库。</p>
   *
   * @param type
   *     待生成的随机Bean的类型。
   * @return
   *     准备好的随机的Bean。<b>注意：</b>如果该Bean的ID属性（该属性被标记注解{@code Identifier}）
   *     被标记为{@code autoGenerated=true}，则生成的模型的ID属性会被设置为{@code null}.
   * @throws Throwable
   *     如果出现任何错误。
   */
  @SuppressWarnings("unchecked")
  public <T> T prepare(final Class<T> type) throws Throwable {
    return (T) prepare(BeanInfo.of(type));
  }

  /**
   * 生成一个准备好的随机的Bean。
   *
   * <p>若该Bean有任何引用属性(即被{@code @Reference}标注的属性)，则此函数会生成其引
   * 用属性所引用的实体并根据需要将其预先加入数据库。</p>
   *
   * <p>此函数为一个递归函数。</p>
   *
   * @param modelInfo
   *     待生成的随机Bean的信息。
   * @param propertyInParent
   *     待生成的随机Bean在其父对象中所属的属性。若该Bean没有父对象则此参数为{@code null}。
   * @param stack
   *     记录对象树中被引用实体信息的堆栈。
   * @param registry
   *     记录被引用实体的哈希表，用于根据引用路径寻找指定的引用对象。
   * @return
   *     准备好的随机的Bean。<b>注意：</b>如果该Bean的ID属性（该属性被标记注解{@code Identifier}）
   *     被标记为{@code autoGenerated=true}，则生成的模型的ID属性会被设置为{@code null}.
   * @throws Throwable
   *     如果出现任何错误。
   */
  private Object prepareImpl(final BeanInfo modelInfo,
      @Nullable final Property propertyInParent, final EntityInfoStack stack,
      final EntityRegistry registry) throws Throwable {
    logger.debug("prepareImpl: {}", modelInfo.getName());
    final Class<?> type = modelInfo.getType();
    final Object model = random.nextObject(type);
    // 别忘记把 model 的 identifier 设置为 null，否则无法测试出 DAO 是否自动生成
    // 并赋值 identifier
    // 但如果把 identifier 设置为null，某些不依赖自动生成 ID 的 DAO 会直接将 null 的 ID
    // 插入数据库，导致数据库报错
    // 所以我们需要依赖 Identifier.autoGenerated 属性进行判断
    if (modelInfo.hasAutoGeneratedIdProperty()) {
      modelInfo.setId(model, null);
    }
    // 递归处理 model 的所有引用字段
    stack.push(new EntityInfo(type, model, propertyInParent));
    processReferenceProperties(model, modelInfo, stack, registry);
    stack.pop();
    return model;
  }

  /**
   * 处理指定模型对象的所有引用属性值。
   *
   * <p>此函数为一个递归函数。</p>
   *
   * @param model
   *     当前的模型对象。
   * @param modelInfo
   *     当前模型对象的类型信息。注意不能通过{@code BeanInfo.of(model.getClass())}获
   *     取，因为{@code model.getClass()}获得的可能是实际要求类型的子类。
   * @param stack
   *     记录对象树中被引用实体信息的堆栈。
   * @param registry
   *     记录被引用实体的哈希表，用于根据引用路径寻找指定的引用对象。
   * @throws Throwable
   *     如果出现任何错误。
   */
  private void processReferenceProperties(final Object model, final BeanInfo modelInfo,
      final EntityInfoStack stack, final EntityRegistry registry) throws Throwable {
    final EntityInfo entityInfo = stack.peek();
    for (final Property prop : modelInfo.getReferenceProperties()) {
      if (isEmpty(prop.getReferencePath())) {
        if (prop.getValue(model) == null) {
          // 如果该属性随机产生的值是null，无需再修正，直接将其注册到哈希表
          registry.put(model, prop, null);
        } else {
          // 重新设置该引用属性的值，注意下面的函数中会递归调用本函数
          setReferenceProperty(model, prop, stack, registry);
        }
      } else {
        // 对于具有 path 的引用属性，将其加入到对象树中对应节点的 referencedProperties中，
        // 稍后统一处理
        stack.addReferencedProperty(prop);
      }
    }
    // 接下来处理当前堆栈顶部实体对象的 referencedProperties
    // 先对其所有 referencedProperties 进行拓扑排序
    entityInfo.topologySortReferencedProperties();
    // 然后依次对引用了当前实体对象中所有 referencedProperty 进行赋值
    for (final ReferencedProperty prop : entityInfo.getReferencedProperties()) {
      // 根据prop的 referencePath 属性获取指定的实体对象
      final Result<Object> result = getReferencedEntityByPath(model, modelInfo,
          prop.getReferenceEntity(), prop.getReferencePath(), stack, registry);
      if (!result.success) {
        throw new InvalidReferencePathException(modelInfo, prop);
      }
      // 根据该实体对象指定的属性值设置prop属性值
      final Object referToEntity = result.value;
      final Object referToPropValue = getReferToPropertyValue(prop, referToEntity);
      // 根据属性路径设置属性值
      if (! setPropertyValueByPath(model, modelInfo, prop.getPropertyPath(),
            referToEntity, referToPropValue, stack, registry)) {
        throw new InvalidPropertyPathException(modelInfo, prop);
      }
    }
  }

  /**
   * 获取指定模型的指定的引用属性路径对应的值。
   *
   * @param model
   *     指定的模型对象。
   * @param modelInfo
   *     该模型对象的类型信息。
   * @param entityType
   *     指定的引用实体的类型。
   * @param path
   *     指定的引用属性路径。
   * @return
   *     一个{@link Result}对象，封装了指定模型的指定的引用属性路径对应的值，以及该函
   *     数是否成功的标记。
   */
  private Result<Object> getReferencedEntityByPath(final Object model,
      final BeanInfo modelInfo, final Class<?> entityType, final String path,
      final EntityInfoStack stack, final EntityRegistry registry) throws Throwable {
    if (path.isEmpty()) {
      return new Result<>(model, true);  // 递归终止，直接返回获得的结果
    }
    if (path.startsWith(EntityInfo.PARENT_PATH)) {
      // 若路径依然以父对象路径开头，说明不存在父对象；如果存在的话这一级属性应该在前面处理
      // 中就被消解了。此时应该直接准备一个新的实体对象，将其加入数据库，并返回该对象
      // 下面涉及递归调用
      final Object entity = prepareImpl(BeanInfo.of(entityType), null,
          new EntityInfoStack(), new EntityRegistry());
      // 将新实体对象加入数据库
      logger.debug("Adding the existing referenced entity to database: {}", entity);
      final DaoInfo entityDaoInfo = generatorRegistry.getDaoInfo(entityType);
      if (entityDaoInfo == null) {
        throw new EntityDaoNotRegisteredException(entityType);
      }
      entityDaoInfo.add(entity);
      // 返回该实体对象，递归终止
      return new Result<>(entity, true);
    }
    final String propName;        // path所表示的第一级属性的名称
    final String remainedPath;    // path去掉第一级属性后余下的路径
    final int pos = path.indexOf(EntityInfo.PATH_SEPARATOR);
    if (pos >= 0) {               //  path 是一个多级属性路径
      propName = path.substring(0, pos);
      remainedPath = path.substring(pos + 1);
    } else {                      // path 就是一个简单的属性名
      propName = path;
      remainedPath = null;
    }
    final Property prop = modelInfo.getProperty(propName);
    if (prop == null) {
      logger.error("Cannot find the property '{}' of {}.", propName,
          modelInfo.getName());
      return new Result<>(false); // 属性不存在，返回失败
    }
    if (prop.isCollection() || prop.isArray()) {
      // FIXME: 这里暂时不支持列表的索引选择……
      logger.error("The type of {}.{} is a collection or array, which is not supported.",
          modelInfo.getName(), propName);
      return new Result<>(false);
    }
    final Object value;
    final BeanInfo valueBeanInfo;
    if (prop.isDirectReference()) {
      // 若第一级属性是个直接的引用属性
      // 从哈希表中获取前面已经生成的该属性所引用的实体对象
      if (registry.containsKey(model, prop)) {
        value = registry.get(model, prop);
      } else {
        // 若 prop 的路径尚未在哈希表中注册(这是有可能的)，则直接获取该对象的属性值，
        // 并注册到哈希表
        value = prop.getValue(model);
        registry.put(model, prop, value);
      }
      valueBeanInfo = BeanInfo.of(prop.getReferenceEntity());
    } else {
      // 若第一级属性是个间接的引用属性或者不是引用属性
      // 则直接从当前模型中获取该属性的值
      value = prop.getValue(model);
      registry.put(model, prop, value);
      valueBeanInfo = BeanInfo.of(prop.getType());
    }
    if (remainedPath == null) {
      return new Result<>(value, true);   // 递归终止，直接返回获得的结果
    } else if (value == null) {
      return new Result<>(true);          // value允许为null
    } else {
      // 递归地处理余下的属性路径
      return getReferencedEntityByPath(value, valueBeanInfo, entityType, remainedPath,
          stack, registry);
    }
  }

  /**
   * 根据指定的属性路径设置属性值。
   *
   * @param model
   *     指定的模型对象。
   * @param modelInfo
   *     该模型对象的类型信息。
   * @param path
   *     指定的属性路径。
   * @param referToEntity
   *     待设置的属性所引用的实体对象。
   * @param referToPropValue
   *     待设置的属性所引用的实体对象的指定属性值。
   * @return
   *     若给定的属性路径正确，则设置属性值并返回{@code true}；否则返回{@code false}。
   */
  private boolean setPropertyValueByPath(final Object model,
      final BeanInfo modelInfo, final String path, final Object referToEntity,
      final Object referToPropValue, final EntityInfoStack entityInfoStack,
      final EntityRegistry entityRegistry) {
    final String propName;        // path所表示的第一级属性的名称
    final String remainedPath;    // path去掉第一级属性后余下的路径
    final int pos = path.indexOf(EntityInfo.PATH_SEPARATOR);
    if (pos >= 0) {               //  path 是一个多级属性路径
      propName = path.substring(0, pos);
      remainedPath = path.substring(pos + 1);
    } else {                      // path 就是一个简单的属性名
      propName = path;
      remainedPath = null;
    }
    final Property prop = modelInfo.getProperty(propName);
    if (prop == null) {
      logger.error("Cannot find the property '{}' of {}.", propName, modelInfo.getName());
      return false; // 属性不存在，返回失败
    }
    if (remainedPath == null) {   // 递归终止
      // 设置属性值
      prop.setValue(model, referToPropValue);
      // 要将此属性引用的实体记录在哈希表中，后面再设置的其他引用属性可能会通过path引用到此实体的属性
      entityRegistry.put(model, prop, referToEntity);
      return true;
    } else {                      // 递归地处理余下的属性路径
      final Object value = prop.getValue(model);
      final BeanInfo valueInfo = BeanInfo.of(prop.getType());
      if (value == null) {
        logger.warn("The value of the property '{}' of {} is null.",
            propName, modelInfo.getName());
        // 注意我们允许路径最终的属性不存在的情况，比如路径包含一个数组或集合属性，其中部分元素
        // 的余下路径存在，部分不存在，这是允许的。所以这里返回true
        return true;
      }
      if (prop.isCollection()) {
        // 对集合中每个元素，依次按照余下的属性路径设置其属性值
        final Collection<?> col = (Collection<?>) value;
        for (final Object obj : col) {
          if (obj != null) {
            final Class<?> cls = obj.getClass();
            if (! setPropertyValueByPath(obj, BeanInfo.of(cls), remainedPath,
                referToEntity, referToPropValue, entityInfoStack, entityRegistry)) {
              return false;
            }
          }
        }
        return true;
      } else if (prop.isArray()) {
        // 对数组中每个元素，依次按照余下的属性路径设置其属性值
        final Object[] array = (Object[]) value;
        for (final Object obj : array) {
          if (obj != null) {
            final Class<?> cls = obj.getClass();
            if (! setPropertyValueByPath(obj, BeanInfo.of(cls), remainedPath,
                referToEntity, referToPropValue, entityInfoStack, entityRegistry)) {
              return false;
            }
          }
        }
        return true;
      } else {
        // 递归处理余下的属性路径
        return setPropertyValueByPath(value, valueInfo, remainedPath,
            referToEntity, referToPropValue, entityInfoStack, entityRegistry);
      }
    }
  }

  /**
   * 设置引用属性值。
   *
   * <p>此函数将递归地创建随机的被引用实体对象，根据需要将其加入数据库，并将其指定属性值
   * 设置为指定模型对象的引用属性值。</p>
   *
   * @param model
   *     当前的模型对象。
   * @param property
   *     当前的引用属性。
   * @throws Throwable
   *     若发生任何错误。
   */
  private void setReferenceProperty(final Object model, final Property property,
      final EntityInfoStack stack, final EntityRegistry registry)
      throws Throwable {
    final Class<?> entityType = property.getReferenceEntity();
    if (property.isIndirectReference()) {
      // 该属性本身没有直接引用其他实体，但其内部属性引用了其他实体，因此需要递归处理其内部属性
      final Object value = property.getValue(model);
      final BeanInfo valueInfo = BeanInfo.of(property.getType());
      // 递归处理此属性值所有内部引用属性
      stack.push(new EntityInfo(valueInfo.getType(), value, property));
      processReferenceProperties(value, valueInfo, stack, registry);
      stack.pop();
    //    } else if (!property.isReferenceExisting()) {
    //      // 如果该属性可以为不存在的对象，则可设置为随机对象
    //      setReferencePropertyToNonExistingValue(model, property);
    } else if (stack.containsType(entityType)) {  // 发现一个循环依赖
      if (property.isNullable()) {
        // 如果该属性可以为null则直接设置为null解决循环
        setReferencePropertyToNullValue(model, property, stack, registry);
      } else {
        // 否则只能报错
        stack.push(new EntityInfo(entityType, property.getValue(model)));
        throw new ReferenceDependencyLoopException(stack.getTypeStack());
      }
    } else {  // 一般情况
      setReferencePropertyToExistingValue(model, property, stack, registry);
    }
  }

  /**
   * 设置引用属性值为null值。
   *
   * @param model
   *     当前的模型对象。
   * @param property
   *     当前的引用属性。
   */
  private void setReferencePropertyToNullValue(final Object model,
      final Property property, final EntityInfoStack entityInfoStack,
      final EntityRegistry entityRegistry) {
    // 如果该属性可以为null则直接设置为null解决循环
    property.setValue(model, null);
    // 同时也记录在被引用实体哈希表中
    entityRegistry.put(model, property, null);
  }

  //  /**
  //   * 设置引用属性值为不存在于数据库中的随机值。
  //   *
  //   * <p>此函数将递归地创建随机的被引用实体对象，但并不需要将其加入数据库，直接将其指定属性值设
  //   * 置为指定模型对象的引用属性值。</p>
  //   *
  //   * <p>此函数不存在递归调用。</p>
  //   *
  //   * @param model
  //   *     当前的模型对象。
  //   * @param property
  //   *     当前的引用属性。
  //   */
  //  private void setReferencePropertyToNonExistingValue(final Object model,
  //      final Property property, final EntityInfoStack entityInfoStack,
  //      final EntityRegistry entityRegistry) {
  //    final Class<?> entityType = property.getReferenceEntity();
  //    if (property.isArray() || property.isCollection()) {
  //      // 对当前引用属性为数组或集合的情况，随机生成若干被引用实体，并获取其被引用值
  //      final CloseRange<Integer> range = defaultIfNull(property.getSizeRange(),
  //          DEFAULT_SIZE_RANGE);
  //      final int n = random.nextInt(range);
  //      final List<Object> entities = new ArrayList<>();
  //      final List<Object> values = new ArrayList<>();
  //      for (int i = 0; i < n; ++i) {
  //        final Object entity = random.nextObject(entityType);
  //        entities.add(entity);
  //        final Object value = getReferToPropertyValue(property, entity);
  //        values.add(value);
  //      }
  //      // 在registry中记录当前对象当前属性所引用的实体列表
  //      entityRegistry.put(model, property, entities);
  //      if (property.isCollection()) {
  //        property.setValue(model, values);
  //      } else {
  //        // property.isArray() == true
  //        property.setValue(model, values.toArray());
  //      }
  //    } else {
  //      final Object entity = random.nextObject(entityType);
  //      final Object value = getReferToPropertyValue(property, entity);
  //      property.setValue(model, value);
  //    }
  //  }

  /**
   * 一般情况下，设置引用属性值为存在于数据库中的随机值。
   *
   * <p>此函数将递归地创建随机的被引用实体对象，根据需要将其加入数据库，并将其指定属性值
   * 设置为指定模型对象的引用属性值。</p>
   *
   * @param model
   *     当前的模型对象。
   * @param property
   *     当前的引用属性。
   * @throws Throwable
   *     若发生任何错误。
   */
  private void setReferencePropertyToExistingValue(final Object model,
      final Property property, final EntityInfoStack stack,
      final EntityRegistry registry) throws Throwable {
    final Object value;
    if (property.isArray() || property.isCollection()) {
      // 对当前引用属性为数组或集合的情况，随机生成若干被引用实体，并获取其被引用值
      final CloseRange<Integer> range = defaultIfNull(property.getSizeRange(),
          DEFAULT_SIZE_RANGE);
      final int n = random.nextInt(range);
      value = prepareReferToValue(n, model, property, stack, registry);    // 会触发递归调用
    } else {
      value = prepareReferToValue(model, property, stack, registry);       // 会触发递归调用
    }
    property.setValue(model, value);
  }

  /**
   * 准备引用属性的多个属性值，该引用属性必须是一个集合或数组。
   *
   * @param count
   *     引用属性集合/数组中的元素数目。
   * @param model
   *     当前的模型对象。
   * @param property
   *     当前的引用属性。
   * @return
   *     当前的引用属性的多个属性值。
   * @throws Throwable
   *     若发生任何错误。
   */
  private Object prepareReferToValue(final int count, final Object model,
      final Property property, final EntityInfoStack stack,
      final EntityRegistry registry) throws Throwable {
    final List<Object> entities = new ArrayList<>();
    final List<Object> values = new ArrayList<>();
    for (int i = 0; i < count; ++i) {
      final Object entity = prepareReferToEntity(property, stack, registry);
      entities.add(entity);
      final Object value = getReferToPropertyValue(property, entity);
      values.add(value);
    }
    // 在registry中记录当前对象当前属性所引用的实体列表
    registry.put(model, property, entities);
    if (property.isCollection()) {
      return values;
    } else if (property.isArray()) {
      return values.toArray();
    } else {
      throw new IllegalArgumentException("Unsupported property type, it must be "
          + "either a collection or an array: " + property.getType().getName());
    }
  }

  /**
   * 准备引用属性的单个属性值。
   *
   * @param model
   *     当前的模型对象。
   * @param property
   *     当前的引用属性。
   * @return
   *     当前的引用属性的单个属性值。
   * @throws Throwable
   *     若发生任何错误。
   */
  private Object prepareReferToValue(final Object model, final Property property,
      final EntityInfoStack stack, final EntityRegistry registry)
      throws Throwable {
    final Object entity = prepareReferToEntity(property, stack, registry);
    // 在registry中记录当前对象当前属性所引用的实体
    registry.put(model, property, entity);
    // 获取被引用实体的指定属性值，作为当前对象当前属性的值
    return getReferToPropertyValue(property, entity);
  }

  /**
   * 准备被引用的实体对象。
   *
   * @param property
   *     当前的引用属性。
   * @return
   *     被引用的实体对象。
   * @throws Throwable
   *     若发生任何错误。
   */
  private Object prepareReferToEntity(final Property property,
      final EntityInfoStack stack, final EntityRegistry registry)
      throws Throwable {
    final Class<?> entityType = property.getReferenceEntity();
    final BeanInfo entityInfo = BeanInfo.of(entityType);
    // 递归调用prepareImpl()准备好当前对象当前属性所引用的实体
    final Object entity = prepareImpl(entityInfo, property, stack, registry);
    if (property.isReferenceExisting()) {
      // 若被引用实体要求是已存在实体，则将其加入数据库
      logger.debug("Adding the existing referenced entity to database: {}", entity);
      final DaoInfo entityDaoInfo = this.generatorRegistry.getDaoInfo(entityType);
      if (entityDaoInfo == null) {
        throw new EntityDaoNotRegisteredException(entityType);
      }
      entityDaoInfo.add(entity);
    }
    return entity;
  }

  /**
   * 获取被引用实体的被引用属性值。
   *
   * @param property
   *     当前的引用属性。
   * @param referToEntity
   *     当前的引用属性所引用的实体。
   * @return
   *     当前的引用属性所引用的实体的指定的被引用属性值。
   */
  private Object getReferToPropertyValue(final ReferencedProperty property,
      @Nullable final Object referToEntity) {
    if (referToEntity == null) {
      return null;
    }
    final String referToPropName = property.getReferenceProperty();
    if (referToPropName.isEmpty()) {
      return referToEntity;
    } else {
      final Class<?> referToEntityType = property.getReferenceEntity();
      final BeanInfo referToEntityTypeInfo = BeanInfo.of(referToEntityType);
      return referToEntityTypeInfo.get(referToEntity, referToPropName);
    }
  }

  /**
   * 获取被引用实体的被引用属性值。
   *
   * @param property
   *     当前的引用属性。
   * @param referToEntity
   *     当前的引用属性所引用的实体。
   * @return
   *     当前的引用属性所引用的实体的指定的被引用属性值。
   */
  private Object getReferToPropertyValue(final Property property,
      @Nullable final Object referToEntity) {
    if (referToEntity == null) {
      return null;
    }
    final String referToPropName = property.getReferenceProperty();
    if (referToPropName.isEmpty()) {
      return referToEntity;
    } else {
      final Class<?> referToEntityType = property.getReferenceEntity();
      final BeanInfo referToEntityTypeInfo = BeanInfo.of(referToEntityType);
      return referToEntityTypeInfo.get(referToEntity, referToPropName);
    }
  }
}
